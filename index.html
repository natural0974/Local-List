<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Texas Local List</title>
  <link rel="stylesheet" href="local.css" />
</head>
<body>
  <!--
    Repo structure (GitHub Pages):
      /index.html
      /styles.css
      /local_list.csv
      /assets/logo.png

    CSV expected columns (header names can vary a bit):
      - Item# / Item / SKU
      - Description / Produce / Item Description
      - Pack
      - UOM
      - Grower / Vendor / Artisan
      - Available Location / Location / Available
      - Category (optional but recommended)

    If you have multiple categories (Produce, Dairy, etc.), include a Category column.
  -->

  <div class="page">
    <header class="brand">
      <img class="logo" src="assets/logo.png" alt="Hardie's logo" onerror="this.style.display='none';" />
      <div class="title">Texas Local List</div>
      <div class="date" id="listDate">12/20/2025</div>
    </header>

    <section class="controls">
      <div class="control">
        <label for="categorySelect">Category</label>
        <select id="categorySelect"></select>
      </div>
      <div class="control">
        <label for="searchInput">Search</label>
        <input id="searchInput" type="search" placeholder="Search item, grower, locationâ€¦" autocomplete="off" />
      </div>
      <div class="control control-small">
        <label for="locationSelect">Location</label>
        <select id="locationSelect"></select>
      </div>
      <div class="control control-small">
        <label for="downloadCsvBtn">&nbsp;</label>
        <button id="downloadCsvBtn" type="button">Download CSV</button>
      </div>
    </section>

    <div class="table-wrap">
      <table class="grid" aria-label="Texas Local List Table">
        <thead>
          <tr class="hdr">
            <th class="col-item">ITEM#</th>
            <th class="col-desc" id="descHeader">PRODUCE</th>
            <th class="col-pack">PACK</th>
            <th class="col-uom">UOM</th>
            <th class="col-grower">GROWER</th>
            <th class="col-loc">AVAILABLE LOCATION</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <footer class="notes" id="notes">
      <!-- Optional: add your footnotes here if you want -->
      <!-- Example: Local produce brought in seasonally. Items marked * may require pre-order. -->
    </footer>

    <div class="error" id="error" role="alert"></div>
  </div>

  <script>
    const CSV_PATH = "local_list.csv";

    // If you want the date to auto-update to "today", set this to true:
    const USE_TODAY_DATE = false;

    // If you keep a date column in your CSV (e.g., "ListDate"), you can wire it later.
    // For now we use the hardcoded date above or today.

    const HEADER_ALIASES = {
      item: ["item#", "item", "sku", "itemnumber", "item number", "product#", "product number"],
      desc: ["produce", "description", "desc", "item description", "product", "product description"],
      pack: ["pack", "packsize", "pack size", "case pack", "casepack"],
      uom:  ["uom", "unit", "unit of measure", "unitofmeasure"],
      grower: ["grower", "vendor", "artisan", "farm", "producer", "brand"],
      loc: ["available location", "available", "location", "locations", "whse", "warehouse"],
      category: ["category", "cat", "section", "department", "dept"]
    };

    let rows = [];
    let headers = [];
    let map = {};
    let currentCategory = "";
    let currentLocation = "";
    let currentQuery = "";

    function norm(s) {
      return String(s ?? "").trim().toLowerCase().replace(/\s+/g, " ").replace(/[^\w#\/ ]+/g, "");
    }

    function parseCSV(text) {
      const out = [];
      let i = 0, field = "", row = [], inQuotes = false;

      while (i < text.length) {
        const c = text[i];

        if (inQuotes) {
          if (c === '"') {
            const next = text[i + 1];
            if (next === '"') { field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          } else {
            field += c; i++; continue;
          }
        } else {
          if (c === '"') { inQuotes = true; i++; continue; }
          if (c === ",") { row.push(field); field = ""; i++; continue; }
          if (c === "\r") { i++; continue; }
          if (c === "\n") { row.push(field); out.push(row); row = []; field = ""; i++; continue; }
          field += c; i++; continue;
        }
      }
      row.push(field);
      out.push(row);

      while (out.length && out[out.length - 1].every(x => String(x).trim() === "")) out.pop();
      return out;
    }

    function buildHeaderMap(hs) {
      const normalized = hs.map(h => ({ raw: h, n: norm(h) }));
      const m = {};
      for (const [key, aliases] of Object.entries(HEADER_ALIASES)) {
        for (const a of aliases) {
          const found = normalized.find(x => x.n === norm(a));
          if (found) { m[key] = found.raw; break; }
        }
      }
      return m;
    }

    function v(row, key) {
      const h = map[key];
      return h ? (row[h] ?? "") : "";
    }

    function parseLocations(val) {
      const s = String(val ?? "").toUpperCase();
      const parts = s.split(/[,\/;|]+|\s{2,}/g).map(x => x.trim()).filter(Boolean);
      if (parts.length <= 1 && s.includes(" ")) {
        const maybe = s.split(/\s+/g).map(x => x.trim()).filter(Boolean);
        if (maybe.every(x => /^[A-Z0-9]{2,6}$/.test(x))) return [...new Set(maybe)];
      }
      return [...new Set(parts)];
    }

    function setError(msg) {
      document.getElementById("error").textContent = msg || "";
    }

    function fillSelect(selectEl, items, allLabel) {
      selectEl.innerHTML = "";
      const all = document.createElement("option");
      all.value = "";
      all.textContent = allLabel;
      selectEl.appendChild(all);

      for (const it of items) {
        const opt = document.createElement("option");
        opt.value = it;
        opt.textContent = it;
        selectEl.appendChild(opt);
      }
    }

    function applyUIHeader(category) {
      // Match your screenshot: the description column header is the category name (e.g., PRODUCE)
      const hdr = document.getElementById("descHeader");
      hdr.textContent = (category || "DESCRIPTION").toUpperCase();
    }

    function render() {
      const tbody = document.getElementById("tbody");
      tbody.innerHTML = "";

      const filtered = rows.filter(r => {
        if (map.category && currentCategory) {
          if (String(v(r, "category")).trim() !== currentCategory) return false;
        }

        if (currentLocation) {
          const locs = parseLocations(v(r, "loc"));
          if (!locs.includes(currentLocation)) return false;
        }

        if (currentQuery) {
          const blob = (String(v(r,"item")) + " " + String(v(r,"desc")) + " " + String(v(r,"grower")) + " " + String(v(r,"loc"))).toLowerCase();
          if (!blob.includes(currentQuery)) return false;
        }

        return true;
      });

      const frag = document.createDocumentFragment();

      for (const r of filtered) {
        const tr = document.createElement("tr");

        const tdItem = document.createElement("td");
        tdItem.className = "col-item";
        tdItem.textContent = String(v(r, "item")).trim();

        const tdDesc = document.createElement("td");
        tdDesc.className = "col-desc";
        tdDesc.textContent = String(v(r, "desc")).trim();

        const tdPack = document.createElement("td");
        tdPack.className = "col-pack";
        tdPack.textContent = String(v(r, "pack")).trim();

        const tdUom = document.createElement("td");
        tdUom.className = "col-uom";
        tdUom.textContent = String(v(r, "uom")).trim();

        const tdGrower = document.createElement("td");
        tdGrower.className = "col-grower";
        tdGrower.textContent = String(v(r, "grower")).trim();

        const tdLoc = document.createElement("td");
        tdLoc.className = "col-loc";
        tdLoc.textContent = String(v(r, "loc")).trim();

        tr.appendChild(tdItem);
        tr.appendChild(tdDesc);
        tr.appendChild(tdPack);
        tr.appendChild(tdUom);
        tr.appendChild(tdGrower);
        tr.appendChild(tdLoc);

        frag.appendChild(tr);
      }

      tbody.appendChild(frag);
    }

    async function load() {
      setError("");

      try {
        // Date display
        if (USE_TODAY_DATE) {
          document.getElementById("listDate").textContent = new Date().toLocaleDateString();
        }

        const res = await fetch(CSV_PATH, { cache: "no-store" });
        if (!res.ok) throw new Error(`Could not load ${CSV_PATH} (HTTP ${res.status}).`);
        const text = await res.text();

        const parsed = parseCSV(text);
        if (!parsed.length) throw new Error("CSV appears empty.");

        headers = parsed[0].map(h => String(h ?? "").trim());
        map = buildHeaderMap(headers);

        if (!map.item || !map.desc) {
          throw new Error("CSV headers not recognized. Make sure you have Item# and Description/Produce columns.");
        }

        rows = parsed.slice(1)
          .filter(r => r.some(cell => String(cell ?? "").trim() !== ""))
          .map(r => {
            const obj = {};
            headers.forEach((h, i) => obj[h] = r[i] ?? "");
            return obj;
          });

        // Category dropdown
        const catSelect = document.getElementById("categorySelect");
        const hasCategory =

